name: Resource Convert

on:
  issues:
    types: [labeled]

permissions:
  issues: write
  contents: read

jobs:
  convert-resource-pack:
    if: github.event.label.name == 'build'
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download attachment
        id: download
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const fs = require('fs');
              const path = require('path');
              const { execSync } = require('child_process');
              
              const issueBody = context.payload.issue.body || '';
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              const textToSearch = [issueBody];
              for (const comment of comments.data) {
                textToSearch.push(comment.body);
              }
              
              let attachmentUrl = null;
              let fileName = null;
              
              for (const text of textToSearch) {
                const regex = /https:\/\/github\.com\/[^\/\s]+\/(?:files|user-attachments\/files)\/[^\/\s]+\/[^\/\s]+\.zip/gi;
                const matches = text.match(regex);
                
                if (matches && matches.length > 0) {
                  attachmentUrl = matches[0];
                  fileName = path.basename(attachmentUrl);
                  break;
                }
                
                const mdLinkRegex = /\[.*?\]\((https:\/\/github\.com\/[^\/\s]+\/(?:files|user-attachments\/files)\/[^\/\s]+\/[^\/\s]+\.zip)\)/gi;
                let mdMatch;
                
                while ((mdMatch = mdLinkRegex.exec(text)) !== null) {
                  attachmentUrl = mdMatch[1];
                  fileName = path.basename(attachmentUrl);
                  break;
                }
                
                if (attachmentUrl) break;
              }
              
              if (!attachmentUrl) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: '🚫 **エラー**: ZIP ファイル形式のリソースパックが見つかりませんでした。\n\nIssue本文またはコメントにZIPファイルのURLを記載してください。'
                });
                core.setFailed('ZIPファイルが見つかりませんでした');
                return;
              }
              
              const downloadPath = path.join(process.env.GITHUB_WORKSPACE, fileName);
              execSync(`curl -L "${attachmentUrl}" -o "${downloadPath}"`);
              
              core.setOutput('file_path', downloadPath);
              core.setOutput('file_name', fileName);
              core.setOutput('download_success', 'true');
              return { file_path: downloadPath, file_name: fileName };
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `🚫 **ダウンロードエラー**: ${error.message}`
              });
              throw error;
            }

      - name: Notify file detection
        if: steps.download.outputs.download_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fileName = '${{ steps.download.outputs.file_name }}';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `📦 ZIP リソースパックファイル「**${fileName}**」が検出されました。\n\n変換処理を開始します...お待ちください。`
            });

      - name: Convert resource pack
        id: convert
        if: steps.download.outputs.download_success == 'true'
        shell: powershell
        run: |
          # UTF-8エンコーディングを強制
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $OutputEncoding = [System.Text.Encoding]::UTF8
          
          try {
            $filePath = "${{ steps.download.outputs.file_path }}"
            $outputPath = "${{ runner.temp }}/converted_${{ steps.download.outputs.file_name }}"
            
            cd ${{ github.workspace }}
            
            # McEncryptorのパス
            $mcEncPath = Join-Path ${{ github.workspace }} "MCEnc\McEncryptor.exe"
            
            Write-Host "MCEnc ディレクトリ内のファイル一覧:"
            Get-ChildItem -Path "MCEnc" -Force | ForEach-Object { Write-Host $_.FullName }
            
            # 単純な方法でMcEncryptorを実行する
            Write-Host "McEncryptorを実行します: $mcEncPath"
            
            # 現在のディレクトリを確認
            $currentDir = Get-Location
            Write-Host "現在の作業ディレクトリ: $currentDir"
            
            # 単純なコマンドライン実行
            Write-Host "シンプルなコマンド実行を試みます"
            
            # 入力ファイルの存在を確認
            if (Test-Path $filePath) {
                Write-Host "変換元ファイルが存在します: $filePath"
            } else {
                Write-Host "エラー: 変換元ファイル $filePath が見つかりません"
            }
            
            # 直接エコーコマンドでパイプ
            cmd /c "echo $filePath | $mcEncPath"
            
            Write-Host "McEncryptorの実行が完了しました。出力ファイルを検索します。"
            
            # 変換完了まで少し長めに待機
            Write-Host "変換処理の完了を待機中..."
            Start-Sleep -Seconds 15
            
            # 変換されたファイルを複数の方法で探索
            Write-Host "変換されたファイルを探索中..."
            
            # 方法1: 元ファイル名に基づく検索
            $fileNameWithoutExt = [System.IO.Path]::GetFileNameWithoutExtension($filePath)
            Write-Host "ファイル名(拡張子なし): $fileNameWithoutExt"
            
            # 方法2: ワークスペース全体を検索
            Write-Host "ワークスペース全体のZIPファイルを検索:"
            $allZips = Get-ChildItem -Path ${{ github.workspace }} -Recurse -Filter "*.zip" | Where-Object { $_.FullName -ne $filePath }
            
            foreach ($zip in $allZips) {
                Write-Host "ZIPファイル発見: $($zip.FullName) (最終更新: $($zip.LastWriteTime))"
            }
            
            # 最も新しいZIPファイルを選択
            $convertedFile = $allZips | Sort-Object LastWriteTime -Descending | Select-Object -First 1
            
            if ($convertedFile) {
              Write-Host "変換されたファイルが見つかりました: $($convertedFile.FullName)"
              Move-Item -Path $convertedFile.FullName -Destination $outputPath -Force
              "converted_file_path=$outputPath" >> $env:GITHUB_OUTPUT
              "converted_file_name=$($convertedFile.Name)" >> $env:GITHUB_OUTPUT
              "conversion_success=true" >> $env:GITHUB_OUTPUT
            } else {
              Write-Host "変換ファイル検索結果:"
              Get-ChildItem -Path ${{ github.workspace }} -Recurse -Filter "*.zip" | ForEach-Object { Write-Host $_.FullName }
              "conversion_success=false" >> $env:GITHUB_OUTPUT
              Write-Output "::error::Converted file not found"
              exit 1
            }
          } 
          catch {
            Write-Host "エラー詳細: $_"
            "conversion_success=false" >> $env:GITHUB_OUTPUT
            Write-Output "::error::Conversion failed: $($_.Exception.Message)"
            exit 1
          }

      - name: Notify conversion error
        if: failure() && steps.convert.conclusion == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `❌ **変換エラー**: リソースパックの変換に失敗しました。\n\nファイルが破損しているか、対応していない形式の可能性があります。`
            });

      - name: Upload converted file
        if: steps.convert.outputs.conversion_success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: converted-resource-pack
          path: ${{ steps.convert.outputs.converted_file_path }}
          retention-days: 7

      - name: Create download link
        id: download_link
        if: steps.convert.outputs.conversion_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            core.setOutput('url', downloadUrl);
            return { url: downloadUrl };

      - name: Complete and close issue
        if: steps.convert.outputs.conversion_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const downloadUrl = '${{ steps.download_link.outputs.url }}';
            const fileName = '${{ steps.convert.outputs.converted_file_name }}';
            const originalFileName = '${{ steps.download.outputs.file_name }}';
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['converted']
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `✅ **リソースパックの変換が完了しました！**\n\n📄 元のファイル: **${originalFileName}**\n📦 変換されたファイル: **${fileName}**\n\n[📥 ダウンロードリンク](${downloadUrl})\n\n*このファイルは7日間保存されます*\n\n✨ このIssueを自動的にクローズします。`
            });
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            });

      - name: Handle general failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `🚫 **一般エラー**: 予期しないエラーが発生しました。\n\n詳細: https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });
